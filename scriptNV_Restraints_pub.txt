///$tab Main
SET ThousandSep=',';
SET DecimalSep='.';
SET MoneyThousandSep=',';
SET MoneyDecimalSep='.';
SET MoneyFormat='$#,##0.00;($#,##0.00)';
SET TimeFormat='h:mm:ss TT';
SET DateFormat='M/D/YYYY';
SET TimestampFormat='M/D/YYYY h:mm:ss[.fff] TT';
SET FirstWeekDay=6;
SET BrokenWeeks=1;
SET ReferenceDay=0;
SET FirstMonthOfYear=1;
SET CollationLocale='en-US';
SET MonthNames='Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec';
SET LongMonthNames='January;February;March;April;May;June;July;August;September;October;November;December';
SET DayNames='Mon;Tue;Wed;Thu;Fri;Sat;Sun';
SET LongDayNames='Monday;Tuesday;Wednesday;Thursday;Friday;Saturday;Sunday';
//set variables for extract directory
//SET vExtractDirectory = 'lib://Extracts_Clarity_POC';
SET vExtractDirectory = 'lib://Extracts_Clarity_PROD';
// SET vExtractDirectory = 'lib://Extracts_Clarity_AMBTST';
//vExtractDirectory = 'lib://Extracts_Clarity_TST';
SET HidePrefix = '%'

LET vOne = 1;
LET vSixty = 60;                          //60 seconds, 60 minutes
LET vTwentyFour = 24;                            //24 hours in a day
LET vThirty = 30;                                //30 days in a month
LET vThreeSixtyFive = 365.25;                   //365.25 days in a year
LET vHours = $(vSixty) * $(vSixty);            //36,00 seconds
LET vDays = $(vHours) * $(vTwentyFour);       //86,400 seconds
LET vMonths = $(vDays) * $(vThirty);         //2,592,000 seconds
LET vYears = $(vDays) * $(vThreeSixtyFive); //31,557,600 seconds
///$tab Mapping
PATIENT_NAME_MAP:
MAPPING LOAD
PAT_ID,
PAT_NAME 
FROM [$(vExtractDirectory)/CLARITY_PATIENT.qvd]
(qvd);


PATIENT_MRN_MAP:
MAPPING LOAD
PAT_ID,
PAT_MRN_ID
FROM [$(vExtractDirectory)/CLARITY_PATIENT.qvd]
(qvd);

///$tab Mitt Secured R (NV)
//start with linking process from pat_enc (to get pat_enc_csn) through ip_flwsht_rec to Ip_flwsht_meas
Restraints_NV2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Mitt Secured R (NV)'																			as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);
// where
// PAT_ENC_CSN_ID  = '37612019';


inner join (Restraints_NV2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Restraints_NV2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300120'//Mitt Secured R (NV)
OR
FLO_MEAS_ID = '300113' //Emotional State/Behavior Observed/Psychological Status/Behavior Observed/Psychological Status
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
OR
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'  //Only bring in Start or Discontinued
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State/Behavior Observed/Psychological Status/Behavior Observed/Psychological Status - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Restraints_NV2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);

//Load all and order by patient, recorded times, and start, assessments, end

Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Restraints_NV2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

//first grouping process of restraint episodes
//if csn does not equal previous csn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to group from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;


//Identify Start of the Episode by loading csn and group id
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart 
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

//Identify Discontinued of the Episode by loading csn and group id
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) 								as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Restraints_NV2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;

//Must remove time patient was not on unit from denominator (units are not responsible for assessments if patient is off the unit)
//'Returned to Unit' and 'Off Unit' must be brought in here and not in the initial load to ensure we are only bringing them in while the patient was on restriants  
Restraints_NV:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,  //recreate meas_value order, including off unit and returned during active restraint episode
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,       //unique identifier to join in updated order sequence 
recno()																as [rec num]
Resident
Restraints_NV2
where [Recorded Time] >= GroupStart									//only bring in off unit and returned to unit during restraint episode
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Field Meas_Value_Order1;										//drop previous order identifier 

Drop Table Restraints_NV2;

//create grouping using peek when a new csn appears, start restraint, or back on unit 
on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] 									as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Restraints_NV
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

//join group_id2 (grouping id for patient episode and patient back on unit)
Left join (Restraints_NV)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;


Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1 //assessments should not be included before or after active restraints, previously end time was not included to stop the inclusion of group assessments and off-unit and on-unit
Resident
Restraints_NV
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;




left Join (Restraints_NV)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;

//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Restraints_NV
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Restraints_NV
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Restraints_NV)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;

Restraints_NV1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,			//1- start or back on unit, 3 = discontinued or off unit
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from original load
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  							as pat_enc_time,
GroupStart1														as GroupStart,
GroupEnd1														as GroupEnd
Resident
Restraints_NV
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017')
and
GroupStart1<= [Recorded Time]
and
GroupEnd1>= [Recorded Time];


Drop Table Restraints_NV;

////////////////////////////////////////////////////////////////////////////////////////
//beging to assess that all assessment rows were completed within 2 hours or each other
//ex. if need to compare if circulation was completed within 2 hours of restratint start or back to unit, and then within 2 hours of one another
Left Join (Restraints_NV1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  								as Testing_interval
Resident
Restraints_NV1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 

//assess if each assessment row was completed within 2 hours of previous assessment - if so 1, if not 0
Left Join (Restraints_NV1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 										as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 			as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 			as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'
Resident
Restraints_NV1
where
Meas_Value_Order = '2'  //where it is an assessment row
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

//now that we have assessed compliance between same rows, we need to attribute compliance only if ALL 8 rows were compliants
//join on test_line and create groups
//ex. if circultation line flo id = previous (circultation line flo id) and group id = previous group id, add 1
//by doing this for all assessment groups, we now have group number for first time all 8 assessments were done, second time assessments were done, etc.
Left join (Restraints_NV1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Restraints_NV1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

//with new group order - can now identify if all 8 rows were compliant, because only if all 8 were compliant was it a compliant assessment
Temp_31:
Load
check_order,
group_id1,
min(test_line)   																as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) 											as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) 			as [Compliant Group Assessment?],
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') 			as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) 														as Sum_Test
Resident 
[Restraints_NV1]
Where Meas_Value_Order = 2
group by
group_id1, 
check_order;


Left join ([Restraints_NV1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;

// now that we have overall assessment compliant points, identify how many compliant points we SHOULD have from start to end of episode
Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Restraints_NV1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;

Left Join (Restraints_NV1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Restraints_NV1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Restraints_NV1
Where 
num(GroupEnd)>num([Recorded Time]);

LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

Restraints_Pat_enc:
Load
*
Resident 
Restraints_NV1;

Drop Table Restraints_NV1;



///$tab Mitt Secured L (NV)
Mitt_Secured_L2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Mitt Secured L (NV)'																			as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);


inner join (Mitt_Secured_L2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Mitt_Secured_L2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300121'//Mitt Secured L (NV)
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
or
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Mitt_Secured_L2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Mitt_Secured_L2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Mitt_Secured_L2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;


//>= and <= groupstart and end because at this point the table is null in those fields if this restraint is not active, but before app was pulling in off unit and back on unit values from other restraints
Mitt_Secured_L:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Mitt_Secured_L2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;

Drop Table Mitt_Secured_L2;

on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Mitt_Secured_L
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Mitt_Secured_L)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;


Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1 //assessments should not be included before or after active restraints, previously end time was not included to stop the inclusion of group assessments and off-unit and on-unit
Resident
Mitt_Secured_L
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;




left Join (Mitt_Secured_L)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;

//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Mitt_Secured_L
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Mitt_Secured_L
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Mitt_Secured_L)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;

Mitt_Secured_L1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,			//1- start or back on unit, 3 = discontinued or off unit
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from original load
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  							as pat_enc_time,
GroupStart1														as GroupStart,
GroupEnd1														as GroupEnd
Resident
Mitt_Secured_L
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017')
and
GroupStart1<= [Recorded Time]
and
GroupEnd1>= [Recorded Time];


Drop Table Mitt_Secured_L;


Left Join (Mitt_Secured_L1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Mitt_Secured_L1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Mitt_Secured_L1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Mitt_Secured_L1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Mitt_Secured_L1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Mitt_Secured_L1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) as Sum_Test
Resident 
[Mitt_Secured_L1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Mitt_Secured_L1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Mitt_Secured_L1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Mitt_Secured_L1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Mitt_Secured_L1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Mitt_Secured_L1
Where 
num(GroupEnd)>num([Recorded Time]);


Concatenate (Restraints_Pat_enc)
LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

Load
*
Resident 
Mitt_Secured_L1;

Drop Table Mitt_Secured_L1; 



///$tab Soft Restraint L Wrist (NV)
Soft_Restraint_L_Wrist2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Soft Restraint L Wrist NV'																	    as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);
// Where
// PAT_ENC_CSN_ID = '37565152';


inner join (Soft_Restraint_L_Wrist2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Soft_Restraint_L_Wrist2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300123'//Soft Restraint L Wrist NV
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
or
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Soft_Restraint_L_Wrist2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Soft_Restraint_L_Wrist2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;
//changed to min in case there are multiple discontinued time entered
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;




Drop Table TimeTable;



Left Join (Soft_Restraint_L_Wrist2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;


//update meas value order to include returned to unit and off unit
//where >= and <= groupstart and end bc string value of 'returned' and 'off unit' creating fields for 1 and 3, only want those 1's and 3's DURING EPISODE (compared to those listed for other restraint types)
Soft_Restraint_L_Wrist:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Soft_Restraint_L_Wrist2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;



Drop Table Soft_Restraint_L_Wrist2;

//exit script;

//now assign groups based off of start to dc, or start to off unit, and back to unit to dc
on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Soft_Restraint_L_Wrist
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Soft_Restraint_L_Wrist)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;

Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1 //assessments should not be included before or after active restraints, previously end time was not included to stop the inclusion of group assessments and off-unit and on-unit
Resident
Soft_Restraint_L_Wrist
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;




left Join (Soft_Restraint_L_Wrist)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;

//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Soft_Restraint_L_Wrist
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Soft_Restraint_L_Wrist
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Soft_Restraint_L_Wrist)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;

Soft_Restraint_L_Wrist1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,			//1- start or back on unit, 3 = discontinued or off unit
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from original load
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  							as pat_enc_time,
GroupStart1														as GroupStart,
GroupEnd1														as GroupEnd
Resident
Soft_Restraint_L_Wrist
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017')
and
GroupStart1<= [Recorded Time]
and
GroupEnd1>= [Recorded Time];


Drop Table Soft_Restraint_L_Wrist;


Left Join (Soft_Restraint_L_Wrist1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Soft_Restraint_L_Wrist1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Soft_Restraint_L_Wrist1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Soft_Restraint_L_Wrist1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Soft_Restraint_L_Wrist1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Soft_Restraint_L_Wrist1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) as Sum_Test
Resident 
[Soft_Restraint_L_Wrist1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Soft_Restraint_L_Wrist1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Soft_Restraint_L_Wrist1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Soft_Restraint_L_Wrist1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Soft_Restraint_L_Wrist1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Soft_Restraint_L_Wrist1
Where 
num(GroupEnd)>num([Recorded Time]);

Concatenate (Restraints_Pat_enc)
LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;


Load
*
Resident 
Soft_Restraint_L_Wrist1;

Drop Table Soft_Restraint_L_Wrist1;




//exit script; 
///$tab Soft Restraint R Wrist (NV)
Soft_Restraint_R_Wrist2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Soft Restraint R Wrist (NV)'																	as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);


inner join (Soft_Restraint_R_Wrist2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Soft_Restraint_R_Wrist2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300122'//Soft Restraint R Wrist (NV)
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
or
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Soft_Restraint_R_Wrist2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Soft_Restraint_R_Wrist2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Soft_Restraint_R_Wrist2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;

//where >= and <= groupstart and end bc string value of 'returned' and 'off unit' creating fields for 1 and 3, only want those 1's and 3's DURING EPISODE (compared to those listed for other restraint types)
Soft_Restraint_R_Wrist:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Soft_Restraint_R_Wrist2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;

Drop Table Soft_Restraint_R_Wrist2;

//now assign groups based off of start to dc, or start to off unit, and back to unit to dc
on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Soft_Restraint_R_Wrist
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Soft_Restraint_R_Wrist)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;

Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1
Resident
Soft_Restraint_R_Wrist
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;


left Join (Soft_Restraint_R_Wrist)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;

//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Soft_Restraint_R_Wrist
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Soft_Restraint_R_Wrist
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Soft_Restraint_R_Wrist)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;


Soft_Restraint_R_Wrist1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from or
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
GroupStart1   as GroupStart, 
GroupEnd1 as GroupEnd 
Resident
Soft_Restraint_R_Wrist
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017')
and 
GroupStart1<= [Recorded Time]
and
GroupEnd1>=[Recorded Time];


Drop Table Soft_Restraint_R_Wrist;



Left Join (Soft_Restraint_R_Wrist1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Soft_Restraint_R_Wrist1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Soft_Restraint_R_Wrist1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Soft_Restraint_R_Wrist1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Soft_Restraint_R_Wrist1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Soft_Restraint_R_Wrist1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) as Sum_Test
Resident 
[Soft_Restraint_R_Wrist1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Soft_Restraint_R_Wrist1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Soft_Restraint_R_Wrist1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Soft_Restraint_R_Wrist1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Soft_Restraint_R_Wrist1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Soft_Restraint_R_Wrist1
Where 
num(GroupEnd)>num([Recorded Time]);





Concatenate (Restraints_Pat_enc)
LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;


Load
*
Resident 
Soft_Restraint_R_Wrist1;

Drop Table Soft_Restraint_R_Wrist1;





///$tab Soft Restraint R Ankle (NV)
Soft_Restraint_R_Ankle2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Soft Restraint R Ankle (NV)'																	as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);


inner join (Soft_Restraint_R_Ankle2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Soft_Restraint_R_Ankle2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300124'//Soft Restraint R Ankle (NV)
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //Released/Circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
or
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Soft_Restraint_R_Ankle2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Soft_Restraint_R_Ankle2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Soft_Restraint_R_Ankle2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;

//update meas value order to include returned to unit and off unit
//where >= and <= groupstart and end bc string value of 'returned' and 'off unit' creating fields for 1 and 3, only want those 1's and 3's DURING EPISODE (compared to those listed for other restraint types)
Soft_Restraint_R_Ankle:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Soft_Restraint_R_Ankle2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;

Drop Table Soft_Restraint_R_Ankle2;

//now assign groups based off of start to dc, or start to off unit, and back to unit to dc
on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Soft_Restraint_R_Ankle
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Soft_Restraint_R_Ankle)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;

Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1
Resident
Soft_Restraint_R_Ankle
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;


left Join (Soft_Restraint_R_Ankle)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;

//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Soft_Restraint_R_Ankle
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Soft_Restraint_R_Ankle
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Soft_Restraint_R_Ankle)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;


Soft_Restraint_R_Ankle1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from or
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
GroupStart1   as GroupStart,  
GroupEnd1 as GroupEnd
Resident
Soft_Restraint_R_Ankle
where
GroupStart1<= [Recorded Time]
and
GroupEnd1>= [Recorded Time]
and
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017');


Drop Table Soft_Restraint_R_Ankle;



Left Join (Soft_Restraint_R_Ankle1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Soft_Restraint_R_Ankle1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Soft_Restraint_R_Ankle1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Soft_Restraint_R_Ankle1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Soft_Restraint_R_Ankle1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Soft_Restraint_R_Ankle1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) as Sum_Test
Resident 
[Soft_Restraint_R_Ankle1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Soft_Restraint_R_Ankle1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Soft_Restraint_R_Ankle1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Soft_Restraint_R_Ankle1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Soft_Restraint_R_Ankle1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Soft_Restraint_R_Ankle1
Where 
num(GroupEnd)>num([Recorded Time]);


Concatenate (Restraints_Pat_enc)
LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;


Load
*
Resident 
Soft_Restraint_R_Ankle1;

Drop Table Soft_Restraint_R_Ankle1;







///$tab Soft Restraint L Ankle (NV)
Soft_Restraint_L_Ankle2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Soft Restraint L Ankle (NV)'																	as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);


inner join (Soft_Restraint_L_Ankle2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Soft_Restraint_L_Ankle2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300125'//Soft Restraint L Ankle (NV)
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
or
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Soft_Restraint_L_Ankle2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Soft_Restraint_L_Ankle2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Soft_Restraint_L_Ankle2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;

// //only pull in time off unit and on unit during restraint episode


//update meas value order to include returned to unit and off unit
//where >= and <= groupstart and end bc string value of 'returned' and 'off unit' creating fields for 1 and 3, only want those 1's and 3's DURING EPISODE (compared to those listed for other restraint types)
Soft_Restraint_L_Ankle:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Soft_Restraint_L_Ankle2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;

Drop Table Soft_Restraint_L_Ankle2;

//now assign groups based off of start to dc, or start to off unit, and back to unit to dc
on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Soft_Restraint_L_Ankle
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Soft_Restraint_L_Ankle)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;

Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1
Resident
Soft_Restraint_L_Ankle
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;


left Join (Soft_Restraint_L_Ankle)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;

//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Soft_Restraint_L_Ankle
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Soft_Restraint_L_Ankle
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Soft_Restraint_L_Ankle)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;



Soft_Restraint_L_Ankle1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from or
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
GroupStart1   as GroupStart,  
GroupEnd1 as GroupEnd

Resident
Soft_Restraint_L_Ankle
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017')
and 
GroupStart1 <= [Recorded Time]
and
GroupEnd1>= [Recorded Time];


Drop Table Soft_Restraint_L_Ankle;



Left Join (Soft_Restraint_L_Ankle1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Soft_Restraint_L_Ankle1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Soft_Restraint_L_Ankle1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Soft_Restraint_L_Ankle1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Soft_Restraint_L_Ankle1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Soft_Restraint_L_Ankle1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) as Sum_Test
Resident 
[Soft_Restraint_L_Ankle1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Soft_Restraint_L_Ankle1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Soft_Restraint_L_Ankle1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Soft_Restraint_L_Ankle1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Soft_Restraint_L_Ankle1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Soft_Restraint_L_Ankle1
Where 
num(GroupEnd)>num([Recorded Time]);




Concatenate (Restraints_Pat_enc)
LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;


Load
*
Resident 
Soft_Restraint_L_Ankle1;

Drop Table Soft_Restraint_L_Ankle1;






///$tab Full Rails (NV)
Full_Rails2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Full Rails (NV)'																	as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);


inner join (Full_Rails2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Full_Rails2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '3040000175'//Full Rails
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
or
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Full_Rails2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Full_Rails2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Full_Rails2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;


//update meas value order to include returned to unit and off unit
//where >= and <= groupstart and end bc string value of 'returned' and 'off unit' creating fields for 1 and 3, only want those 1's and 3's DURING EPISODE (compared to those listed for other restraint types)
Full_Rails:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Full_Rails2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;

Drop Table Full_Rails2;

//now assign groups based off of start to dc, or start to off unit, and back to unit to dc
on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Full_Rails
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Full_Rails)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;

Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1
Resident
Full_Rails
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;


left Join (Full_Rails)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;


//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Full_Rails
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Full_Rails
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Full_Rails)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;


Full_Rails1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from or
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
GroupStart1   as GroupStart,  
GroupEnd1 as GroupEnd

Resident
Full_Rails
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017')
and 
GroupStart1 <= [Recorded Time]
and
GroupEnd1>= [Recorded Time];


Drop Table Full_Rails;


Left Join (Full_Rails1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Full_Rails1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Full_Rails1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Full_Rails1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Full_Rails1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Full_Rails1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) as Sum_Test
Resident 
[Full_Rails1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Full_Rails1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Full_Rails1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Full_Rails1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Full_Rails1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Full_Rails1
Where 
num(GroupEnd)>num([Recorded Time]);


Concatenate (Restraints_Pat_enc)
LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;


Load
*
Resident 
Full_Rails1;

Drop Table Full_Rails1;





///$tab Enclosure Bed (NV)
Enclosure_Bed2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Enclosure Bed (NV)'																	as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);


inner join (Enclosure_Bed2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Enclosure_Bed2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '3040000176'//Enclosure Bed (NV)
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
or
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Enclosure_Bed2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Enclosure_Bed2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Enclosure_Bed2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;


//update meas value order to include returned to unit and off unit
//where >= and <= groupstart and end bc string value of 'returned' and 'off unit' creating fields for 1 and 3, only want those 1's and 3's DURING EPISODE (compared to those listed for other restraint types)
Enclosure_Bed:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Enclosure_Bed2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;

Drop Table Enclosure_Bed2;

//now assign groups based off of start to dc, or start to off unit, and back to unit to dc
on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Enclosure_Bed
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Enclosure_Bed)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;

Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1
Resident
Enclosure_Bed
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;


left Join (Enclosure_Bed)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;


//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Enclosure_Bed
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Enclosure_Bed
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Enclosure_Bed)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;

Enclosure_Bed1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from or
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
GroupStart1   as GroupStart,  
GroupEnd1 as GroupEnd
Resident
Enclosure_Bed
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017')
and 
GroupStart1 <= [Recorded Time]
and
GroupEnd1>= [Recorded Time];



Drop Table Enclosure_Bed;



Left Join (Enclosure_Bed1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Enclosure_Bed1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Enclosure_Bed1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Enclosure_Bed1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Enclosure_Bed1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Enclosure_Bed1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) as Sum_Test
Resident 
[Enclosure_Bed1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Enclosure_Bed1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Enclosure_Bed1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Enclosure_Bed1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Enclosure_Bed1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Enclosure_Bed1
Where 
num(GroupEnd)>num([Recorded Time]);


Concatenate (Restraints_Pat_enc)
LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;


Load
*
Resident 
Enclosure_Bed1;

Drop Table Enclosure_Bed1;





///$tab Seat Belt (Acute Rehab Only)
Seat_Belt2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Seat Belt (Acute Rehab Only)'																	as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);


inner join (Seat_Belt2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Seat_Belt2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '3040000177'//Seat Belt (Acute Rehab Only)
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
or
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Seat_Belt2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Seat_Belt2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Seat_Belt2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;


//update meas value order to include returned to unit and off unit
//where >= and <= groupstart and end bc string value of 'returned' and 'off unit' creating fields for 1 and 3, only want those 1's and 3's DURING EPISODE (compared to those listed for other restraint types)
Seat_Belt:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Seat_Belt2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;

Drop Table Seat_Belt2;

//now assign groups based off of start to dc, or start to off unit, and back to unit to dc
on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Seat_Belt
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Seat_Belt)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;

Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1
Resident
Seat_Belt
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;


left Join (Seat_Belt)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;


//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Seat_Belt
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Seat_Belt
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Seat_Belt)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;



Seat_Belt1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from or
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
GroupStart1   as GroupStart,  
GroupEnd1 as GroupEnd
Resident
Seat_Belt
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017')
and 
GroupStart1 <= [Recorded Time]
and
GroupEnd1>= [Recorded Time];


Drop Table Seat_Belt;


Left Join (Seat_Belt1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Seat_Belt1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Seat_Belt1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Seat_Belt1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Seat_Belt1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Seat_Belt1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) as Sum_Test
Resident 
[Seat_Belt1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Seat_Belt1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Seat_Belt1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Seat_Belt1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Seat_Belt1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Seat_Belt1
Where 
num(GroupEnd)>num([Recorded Time]);



Concatenate (Restraints_Pat_enc)
LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;


Load
*
Resident 
Seat_Belt1;

Drop Table Seat_Belt1;


///$tab Soft Belt
Soft_Belt2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Soft Belt (ICP)(NV)'																	as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);


inner join (Soft_Belt2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Soft_Belt2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '3040000178'//Soft Belt (ICP)(NV)
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
or
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Soft_Belt2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Soft_Belt2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Soft_Belt2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;

//update meas value order to include returned to unit and off unit
//where >= and <= groupstart and end bc string value of 'returned' and 'off unit' creating fields for 1 and 3, only want those 1's and 3's DURING EPISODE (compared to those listed for other restraint types)
Soft_Belt:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Soft_Belt2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;

Drop Table Soft_Belt2;

//now assign groups based off of start to dc, or start to off unit, and back to unit to dc
on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Soft_Belt
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Soft_Belt)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;

Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1
Resident
Soft_Belt
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;


left Join (Soft_Belt)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;



//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Soft_Belt
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Soft_Belt
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Soft_Belt)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;




Soft_Belt1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from or
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
GroupStart1   as GroupStart,  
GroupEnd1 as GroupEnd
Resident
Soft_Belt
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017')
and 
GroupStart1 <= [Recorded Time]
and
GroupEnd1>= [Recorded Time];


Drop Table Soft_Belt;



Left Join (Soft_Belt1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Soft_Belt1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Soft_Belt1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Soft_Belt1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Soft_Belt1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Soft_Belt1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) as Sum_Test
Resident 
[Soft_Belt1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Soft_Belt1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Soft_Belt1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Soft_Belt1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Soft_Belt1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Soft_Belt1
Where 
num(GroupEnd)>num([Recorded Time]);




Concatenate (Restraints_Pat_enc)
LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;


Load
*
Resident 
Soft_Belt1;

Drop Table Soft_Belt1;


///$tab Other
Other2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Other (NV)'																					as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);


inner join (Other2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Other2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State/Behavior Observed/Psychological Status', 'Released/Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300130'//Other
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
or
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Other2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Other2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Min([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Other2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;


//update meas value order to include returned to unit and off unit
//where >= and <= groupstart and end bc string value of 'returned' and 'off unit' creating fields for 1 and 3, only want those 1's and 3's DURING EPISODE (compared to those listed for other restraint types)
Other:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Other2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;

Drop Table Other2;

//now assign groups based off of start to dc, or start to off unit, and back to unit to dc
on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Other
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Other)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;

Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2) and GroupEnd >= [Recorded Time] and GroupStart <= [Recorded Time], group_id2, null()))) as group_id1
Resident
Other
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;


left Join (Other)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;


//adding
TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart1
RESIDENT Other
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

//New table to identify group starts with restraint end or off unit (dropped original groupend that did not include off unit)
Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Min([Recorded Time])) 								as GroupEnd1
RESIDENT Other
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Other)
Load
%Pat_enc_csn,
group_id2,
GroupStart1,
GroupEnd1
Resident TimeTable;

Drop Table TimeTable;


Other1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from or
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
GroupStart1   as GroupStart,  
GroupEnd1 as GroupEnd
Resident
Other
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017')
and 
GroupStart1 <= [Recorded Time]
and
GroupEnd1>= [Recorded Time];


Drop Table Other;


Left Join (Other1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Other1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Other1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Other1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Other1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Other1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    if (sum([Compliant Count])<8, 'Non Compliant Group Assessment') as [Non-Compliant Q2 Assessments],
    sum([Compliant Count]) as Sum_Test
Resident 
[Other1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Other1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?],
[Non-Compliant Q2 Assessments]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Other1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Other1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Other1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Other1
Where 
num(GroupEnd)>num([Recorded Time]);



Concatenate (Restraints_Pat_enc)
LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;


Load
*
Resident 
Other1;

Drop Table Other1;





///$tab Orders 
Order_proc:
Load distinct
%Pat_enc_csn,
GroupStart   										as Start_Res,
GroupEnd 	 										as End_Res,
group_id2 											as group_proc
//[NV Restraint Type]									as NV_R_1
Resident
Restraints_Pat_enc 
order by
%Pat_enc_csn,
group_id2;


left join (Order_proc)
LOAD distinct
    ORDER_PROC_ID   					 			as [Order ID],
    PAT_ID,
    PAT_ENC_CSN_ID 									as %Pat_enc_csn,
    INSTANTIATED_TIME 								as Instatiated_date,
    Date(floor(INSTANTIATED_TIME))					as Order_CAL, 
    FUTURE_OR_STAND

FROM [lib://Extracts_Clarity_PROD/CLARITY_ORDER_PROC.qvd]
(qvd) 
where 
exists (%Pat_enc_csn, PAT_ENC_CSN_ID)
and
INSTANTIATED_TIME <> null() //Due to structure of order proc - each order has duplicate lines (standing and parent), this will only bring back one line
and
PROC_CODE = 'RES4'  //NV Restraint Order
;

//linking parent order and child order together - a 1:1 ratio with restraint, child order has instantiated time, parent order has department and location info
Left join (Order_proc)
LOAD
    INSTNTD_ORDER_ID 								as [Order ID],
    ORDER_ID										as [Inst Link]
FROM [lib://Extracts_Clarity_PROD/CLARITY_ORDER_INSTANTIATED.qvd]
(qvd);

left join (Order_proc)  
LOAD 
ORDER_PROC_ID										as [Inst Link],
ORDER_PROC_ID										as [Inst Link2]
FROM [lib://Extracts_Clarity_PROD/CLARITY_ORDER_PROC.qvd]
(qvd);


LEFT JOIN (Order_proc)
Load
ORDER_ID										as [Inst Link2],
PAT_LOC_ID										as LOC_ID
FROM [lib://Extracts_Clarity_PROD/CLARITY_ORDER_METRICS.qvd]
(qvd);  

Left join (Order_proc)
LOAD
    DEPARTMENT_ID				                    as LOC_ID,
    DEPARTMENT_NAME		  							as [Patient Location]
FROM [lib://Extracts_Clarity_PROD/CLARITY_CLARITY_DEP.qvd]
(qvd);



Order_Proc1:
NoConcatenate
Load Distinct 
*
Resident
Order_proc 
where
(Instatiated_date)<= (End_Res) //only bring in orders less than restraint end time for episode (same order proc could be placed for other restraint types episodes)
and
timestamp(Instatiated_date)>= (timestamp(Start_Res) - 1) //minus 1 day to ensure there is an order active when the clinician documents start of restraint
order by
%Pat_enc_csn,
group_proc;


Drop table Order_proc;  

// create previous order column for comparison, if group proc (which signifies start to end episode) = previous group proc, give me the previous order instantiated time, else give me the restraint start time (to ensure restraints were started with an active order)
Orders:
NoConcatenate
Load Distinct 
%Pat_enc_csn,
[Order ID],
[Patient Location],
//NV_R_1,
group_proc,
Start_Res,
End_Res,
Instatiated_date as inst_date,
Order_CAL, 
if (group_proc = Previous(group_proc), previous(Instatiated_date), Start_Res) as Previous_order,
recno()              as Rec_join
Resident 
Order_Proc1
order By
%Pat_enc_csn,
group_proc,
//NV_R_1,       
Instatiated_date;  

drop table Order_Proc1; 

//if start restraint time = previous order, signifying the first order before the start of restraint episode, subtract that Start Time from the first instantiated order, else give me time between orders during the episode
Left join
(Orders)
Load
Rec_join,
if (Start_Res = Previous_order, 
	(interval(Previous_order - inst_date,'hh:mm:ss')),
    	(interval(inst_date - Previous_order, 'hh:mm:ss'))) as Time_between_orders
//interval(inst_date - Previous_order, 'hh:mm:ss')	as Time_between_orders
Resident
Orders;

//greater than or equal to -1 ensures compliance is not given to orders placed no greater than 1 hours after start of the restraint - ex. start of restraint = 4:00, order placed at 6:00, time between orders = -2
Left join
(Orders)
Load
Rec_join,
if(Time_between_orders <= '24:00:00' and Time_between_orders >= '-01:00:00', 1, 0) as [Compliant Order?]
Resident
Orders; 

// if less than 1 day, requirement is 1 (initial order) greater than 1 (ex 1 day and 1 hour), round up
Left join (Orders)
Load
Rec_join,
if (Interval(End_Res - Start_Res, 'hh:mm:ss')<= '24:00:00', 1,
		(ceil(Interval(End_Res - Start_Res, 'dd')))) 				as Start_to_end_req_orders
Resident
Orders; 


Order_sum:
Load Distinct
//%Pat_enc_csn,
group_proc,
min(Rec_join) as min_join,
sum([Compliant Order?]) as Compliance_Ord,
([Start_to_end_req_orders]) as Order_req,
(sum([Compliant Order?]))/([Start_to_end_req_orders])	 			as [Order Compliance Rate1]
Resident
Orders
group by 
group_proc,
[Start_to_end_req_orders];  


//join back on only one line per Group_proc compliance totals
left join (Orders)
Load Distinct
min_join as Rec_join,
Compliance_Ord as [Total Compliant Orders Placed],
Order_req as [Episode Order Requirements],
if([Order Compliance Rate1]>=1, 1, [Order Compliance Rate1]) 		as [Order Compliance Rate]
Resident   
Order_sum;    

Drop table Order_sum; 


///$tab Departments after orders
Dep1:
LOAD 
    PAT_ENC_CSN 																AS [%Pat_enc_csn],
    Timestamp(IN_DTTM) 															AS [Department Time In1],
    Timestamp(OUT_DTTM) 														AS [Department Time Out2],
    ADT_DEPARTMENT_NAME 														AS [Department Name],
    ADT_LOC_NAME																AS [Location],
    recno()   																	AS dep_rec
FROM [$(vExtractDirectory)/CLARITY_V_PAT_ADT_LOCATION_HX.qvd]
(qvd)
where exists ([%Pat_enc_csn], PAT_ENC_CSN)
and 
ADT_DEPARTMENT_NAME <> 'POST-DISCHARGE'
and 
ADT_DEPARTMENT_NAME <> 'PRE-ADMISSION'
and
ADT_LOC_NAME <> 'POST-DISCHARGE'
and 
ADT_LOC_NAME <> 'PRE-ADMISSION'; 


Dep4:
NoConcatenate
Load distinct 
*,
If ([%Pat_enc_csn] <> previous ([%Pat_enc_csn]), dep_rec,
	if( [Department Name] <> previous ([Department Name]), dep_rec, previous(dep_rec)))     as Department_groups
Resident
Dep1 
order By
[%Pat_enc_csn],
[Department Time In1];

drop table Dep1; 

Dep:
NoConcatenate
Load Distinct 
[%Pat_enc_csn],
[Department Name],
Department_groups,
min(timestamp([Department Time In1]))	 as [Department Time In],
max (timestamp([Department Time Out2]))  as [Department Time Out],
Location
Resident Dep4
Group By
[%Pat_enc_csn],
Department_groups,
[Department Name],   
Location;

drop Table Dep4; 

Inner join (Dep)
LOAD
    PAT_ENC_CSN_ID 																as %Pat_enc_csn,
    INPATIENT_DATA_ID  															as %inpatient_data_id

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd)
where exists ([%Pat_enc_csn], PAT_ENC_CSN_ID);


inner join (Dep)
LOAD
    FSD_ID as %FSD_ID,
    INPATIENT_DATA_ID as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Dep)
LOAD
    FSD_ID as %FSD_ID,
    timestamp(RECORDED_TIME) as [Recorded Time],
    MEAS_VALUE as Value

FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300120'//Mitt Secured R (NV)
OR
FLO_MEAS_ID = '300123'//'Soft Restraint L Wrist NV
or
FLO_MEAS_ID = '300122'//Soft Restraint R Wrist (NV)
OR
FLO_MEAS_ID = '300121'//'Mitt Secured L (NV)'
or 
FLO_MEAS_ID = '300124'//Soft Restraint R Ankle (NV)
or
FLO_MEAS_ID = '300125'//Soft Restraint L Ankle (NV)
or
FLO_MEAS_ID = '3040000175' //full rails 
or
FLO_MEAS_ID = '3040000176' //Enclosure Bed 
or
FLO_MEAS_ID = '3040000177' //seat belt
or
FLO_MEAS_ID = '3040000178' //Soft Belt (ICP)(NV) 
or
FLO_MEAS_ID = '300130' //Other
or
FLO_MEAS_ID = '3040000182' //Returned to unit
OR
FLO_MEAS_ID = '3040000181' // OFF UNIT 
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118')//Elimination
and exists ([Recorded Time], RECORDED_TIME)
and
MEAS_VALUE <> 'Continued'
and
MEAS_VALUE <> null()
and
RECORDED_TIME <> null();

//nested if statement to only pull in recorded times per department while patients was on the department
//concat pat enc and recorded time to join properly per patient and assessment time
Dep1:
NoConcatenate
Load distinct
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
[Department Time In],
[Department Time Out],
if (num([Recorded Time])>=num([Department Time In]),
	IF (num([Recorded Time])< num([Department Time Out]), [Department Name], null())) 	AS Department_1,
[Location]
Resident Dep
where
[Department Name] <> Null()
and 
num([Recorded Time])>=num([Department Time In])
and
num([Recorded Time])< num([Department Time Out])
and 
exists ([%Pat_enc_csn])
and
exists ([Recorded Time]);

Drop Table Dep;



left join (Restraints_Pat_enc)
Load Distinct
pat_enc_time,
Department_1 as Department,
Location,
[Department Time In],
[Department Time Out]
resident Dep1
where
Department_1 <> Null();

Drop Table Dep1;

//Way to distinguish first time department appears on front end - used for calculations of metrics of dep comliance, only want to add calc for denominator once - provides key for first time patient was in new department
Pat_enc_with_dep:
NoConcatenate
Load distinct
*,
if 
([%Pat_enc_csn]= previous ([%Pat_enc_csn]),
    	if([Department Time In] <> previous([Department Time In]), 1, 0)) as Department_CSN_ORDER1,
group_id2 &'-'& Department &'-'& [Assessment Type] as [Compliance by Assessment Type1],
group_id2 &'-'& Department as group_id2_and_dep
Resident 
Restraints_Pat_enc
order by
[%Pat_enc_csn],
group_id2,
[Recorded Time],
Meas_Value_Order;

drop table 
Restraints_Pat_enc; 



///$tab Q2 and Q15 before clin
Q2h:
Load
//group_id2,
group_id2 &'-'& Department as group_id2_and_dep,
if((sum ([All Assessment Rows Complete Count])/
sum(
if((Department_CSN_ORDER1 = 1 OR Meas_Value_Order = 1) and ([Department Time In]>=GroupStart) and (GroupEnd>=[Department Time Out]), floor(Interval([Department Time Out]-[Department Time In])/(121/1440)),
if((Department_CSN_ORDER1 = 1 OR Meas_Value_Order = 1) and (GroupStart >=[Department Time In]) and (GroupEnd >= [Department Time Out]), floor(interval([Department Time Out] - GroupStart)/(121/1440)),
if((Department_CSN_ORDER1  = 1 OR Meas_Value_Order = 1) and (GroupStart<=[Department Time In]) and (GroupEnd<=[Department Time Out]), floor(Interval (GroupEnd - [Department Time In])/(121/1440)),
if((Department_CSN_ORDER1  = 1 OR Meas_Value_Order = 1) and (GroupStart>=[Department Time In]) and (GroupEnd<=[Department Time Out]), floor((interval(GroupEnd - GroupStart)/(121/1440)))))) ) ))>1,1,


(sum ([All Assessment Rows Complete Count])/
sum(
if((Department_CSN_ORDER1 = 1 OR Meas_Value_Order = 1)and ([Department Time In]>=GroupStart) and (GroupEnd>=[Department Time Out]), floor(Interval([Department Time Out]-[Department Time In])/(121/1440)),
if((Department_CSN_ORDER1 = 1 OR Meas_Value_Order = 1) and (GroupStart >=[Department Time In]) and (GroupEnd >= [Department Time Out]), floor(interval([Department Time Out] - GroupStart)/(121/1440)),
if((Department_CSN_ORDER1  = 1 OR Meas_Value_Order = 1) and (GroupStart<=[Department Time In]) and (GroupEnd<=[Department Time Out]), floor(Interval (GroupEnd - [Department Time In])/(121/1440)),
if((Department_CSN_ORDER1  = 1 OR Meas_Value_Order = 1) and (GroupStart>=[Department Time In]) and (GroupEnd<=[Department Time Out]), (floor((interval(GroupEnd - GroupStart)/(121/1440))))))  ))))) as 'Q2H Compliance'
            
Resident
Pat_enc_with_dep
group by
group_id2,
Department;

///////////////////////////////////////////////////////////////////////////////////////////////

Compliance_by_Assessment:
load distinct
group_id2 &'-'& Department &'-'& [Assessment Type] as [Compliance by Assessment Type2],
(sum ([Compliant Count])) as test01,
if(([Department Time In]>=GroupStart) and (GroupEnd>=[Department Time Out]), floor(Interval([Department Time Out]-[Department Time In])/(121/1440)),
if((GroupStart >=[Department Time In]) and (GroupEnd >= [Department Time Out]), floor(interval([Department Time Out] - GroupStart)/(121/1440)),
if((GroupStart<=[Department Time In]) and (GroupEnd<=[Department Time Out]), floor(Interval (GroupEnd - [Department Time In])/(121/1440)),
if((GroupStart>=[Department Time In]) and (GroupEnd<=[Department Time Out]), (floor((interval(GroupEnd - GroupStart)/(121/1440))))))  )) as test02

// if((sum ([Compliant Count])/
// sum(
// if(([Department Time In]>=GroupStart) and (GroupEnd>=[Department Time Out]), floor(Interval([Department Time Out]-[Department Time In])/(121/1440)),
// if((GroupStart >=[Department Time In]) and (GroupEnd >= [Department Time Out]), floor(interval([Department Time Out] - GroupStart)/(121/1440)),
// if((GroupStart<=[Department Time In]) and (GroupEnd<=[Department Time Out]), floor(Interval (GroupEnd - [Department Time In])/(121/1440)),
// if((GroupStart>=[Department Time In]) and (GroupEnd<=[Department Time Out]), floor((interval(GroupEnd - GroupStart)/(121/1440)))))))))>1,1,
// (sum ([Compliant Count])/
// sum(if(([Department Time In]>=GroupStart) and (GroupEnd>=[Department Time Out]), floor(Interval([Department Time Out]-[Department Time In])/(121/1440)),
// if((GroupStart >=[Department Time In]) and (GroupEnd >= [Department Time Out]), floor(interval([Department Time Out] - GroupStart)/(121/1440)),
// if((GroupStart<=[Department Time In]) and (GroupEnd<=[Department Time Out]), floor(Interval (GroupEnd - [Department Time In])/(121/1440)),
// if((GroupStart>=[Department Time In]) and (GroupEnd<=[Department Time Out]), (floor((interval(GroupEnd - GroupStart)/(121/1440))))))  ))))) as 'Q2H Compliance by Assessment Type'
Resident
Pat_enc_with_dep
where
Value <>
'Begin, Continued, or Discontined Time'
and
[Compliant Count] <> 0
group by
[Assessment Type],
group_id2,
Department,
if(([Department Time In]>=GroupStart) and (GroupEnd>=[Department Time Out]), floor(Interval([Department Time Out]-[Department Time In])/(121/1440)),
if((GroupStart >=[Department Time In]) and (GroupEnd >= [Department Time Out]), floor(interval([Department Time Out] - GroupStart)/(121/1440)),
if((GroupStart<=[Department Time In]) and (GroupEnd<=[Department Time Out]), floor(Interval (GroupEnd - [Department Time In])/(121/1440)),
if((GroupStart>=[Department Time In]) and (GroupEnd<=[Department Time Out]), (floor((interval(GroupEnd - GroupStart)/(121/1440))))))  ));


Compliance_by_Assessment2:
NoConcatenate
Load Distinct
[Compliance by Assessment Type2] as [Compliance by Assessment Type1],
test01,
test02,
if((test01/test02)>1, 1,(test01/test02))    as 'Q2H Compliance by Assessment Type'
Resident 
Compliance_by_Assessment;

Drop table 
Compliance_by_Assessment;



///$tab Clin Just/ Less Restrictive/ Education
Clin_just:
LOAD
    PAT_ENC_CSN_ID 																as %Pat_enc_csn,
    INPATIENT_DATA_ID  															as %inpatient_data_id_cl

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd)
where exists ([%Pat_enc_csn], PAT_ENC_CSN_ID);  

//linking process from pat_enc_hsp to ip_flwsht_meas

inner join (Clin_just)
LOAD
    FSD_ID as %FSD_ID_cl,
    INPATIENT_DATA_ID as %inpatient_data_id_cl
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Clin_just)
LOAD
    FSD_ID 										as %FSD_ID_cl,
    timestamp(RECORDED_TIME) 					as [Recorded Time s and cl],
    MEAS_VALUE 									as Value_cls,
    FLO_MEAS_ID 								as flo_meas_cls,
    ENTRY_USER_ID								as [Employee ID Start Res]

FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300120'//Mitt Secured R (NV) 
OR
FLO_MEAS_ID = '300123'//'Soft Restraint L Wrist NV
or
FLO_MEAS_ID = '300122'//Soft Restraint R Wrist (NV)
OR
FLO_MEAS_ID = '300121'//'Mitt Secured L (NV)'
or 
FLO_MEAS_ID = '300124'//Soft Restraint R Ankle (NV)
or
FLO_MEAS_ID = '300125'//Soft Restraint L Ankle (NV)
or
FLO_MEAS_ID = '3040000175' //full rails 
or
FLO_MEAS_ID = '3040000176' //Enclosure Bed 
or
FLO_MEAS_ID = '3040000177' //seat belt
or
FLO_MEAS_ID = '3040000178' //Soft Belt (ICP)(NV) 
or
FLO_MEAS_ID = '300130' //Other
or
FLO_MEAS_ID = '300106' // Clinical justification
or
FLO_MEAS_ID = '300104' // Less Restrictive
//or
//FLO_MEAS_ID = '300108' //Education
OR 
FLO_MEAS_ID = '300109' //Education
OR
FLO_MEAS_ID = '300110' //Education
OR 
FLO_MEAS_ID = '300111') //Education
and
MEAS_VALUE <> 'Continued'
and
MEAS_VALUE <> 'Discontinued'
and
MEAS_VALUE <> null();


//Create table holding all info for all restraint starts, create unique key of pat enc and recorded start time (patient can have multiple starts)
Clin_just2:
NoConcatenate
Load
%Pat_enc_csn,
%Pat_enc_csn &'-'& ([Recorded Time s and cl]) 			as patenc_time,				//creates unique key of pat enc and start times 
%Pat_enc_csn &'-'& ([Recorded Time s and cl]) 			as Unique_restraint_starts, //Therese wants to count episodes as distinct csn and restraint start times (if 2 restraints placed at same time, that is one episode)
date(floor( [Recorded Time s and cl])) 					as Start_date,
[Recorded Time s and cl]								as Start_times,
flo_meas_cls											as flo_meas_starts,
[Employee ID Start Res]
//Employee_start
Resident
Clin_just 
where
flo_meas_cls <> '300106' 
and
flo_meas_cls <> '300104'
and
//flo_meas_cls <> '300108'
//and
flo_meas_cls <> '300109'
and
flo_meas_cls <> '300110'
and
flo_meas_cls <> '300111'
order by
%Pat_enc_csn,
[Recorded Time s and cl];

//left join in field timestamp of clinical justification and education rows if done at time of restraint start (must be done at start of restraints), otherwise will be null
left join (Clin_just2) 
Load
%Pat_enc_csn &'-'& ([Recorded Time s and cl])						as patenc_time,         //unique key
if (flo_meas_cls= '300106', date(floor( [Recorded Time s and cl]))) as Clin_Just_date,		//clinical justification documentation date
if (flo_meas_cls= '300106', [Recorded Time s and cl]) 				as Clin_Just_time		//clinical justification documentation time
Resident Clin_just
where 
flo_meas_cls= '300106' // clinical justification row
order by
%Pat_enc_csn,
[Recorded Time s and cl];

// left join (Clin_just2) 
// Load
// %Pat_enc_csn &'-'& ([Recorded Time s and cl])						as patenc_time,
// [Recorded Time s and cl]											as Ed1_time
// Resident Clin_just
// where 
// flo_meas_cls = '300108'; //education

left join (Clin_just2) 
Load
%Pat_enc_csn &'-'& ([Recorded Time s and cl])						as patenc_time,
[Recorded Time s and cl]							 				as Ed2_time
Resident Clin_just
where 
flo_meas_cls = '300109'; //education


left join (Clin_just2) 
Load
%Pat_enc_csn &'-'& ([Recorded Time s and cl])						as patenc_time,
[Recorded Time s and cl]							 				as Ed3_time
Resident Clin_just
where 
flo_meas_cls = '300110'; //education

left join (Clin_just2) 
Load
%Pat_enc_csn &'-'& ([Recorded Time s and cl])						as patenc_time,
[Recorded Time s and cl]							 				as Ed4_time
Resident Clin_just
where 
flo_meas_cls = '300111'; //education

//if start time = clin just time, if start time = educations times, 1 for compliance otherwise 0 for noncompliance
Clin_just3:
NoConcatenate
Load distinct   
patenc_time as pat_enc_time,
if(Start_times = Clin_Just_time, 1, 0) 								as 'Clinical Justification Documented',
// if(Start_times = Ed1_time, 1, 0) 									as ed_1_documented,
// Ed1_time,
Ed2_time, 
Ed3_time,   
Ed4_time,
if(Start_times = Ed2_time, 1, 0)									as ed_2_documented,
if(Start_times = Ed3_time, 1, 0)									as ed_3_documented,
if(Start_times = Ed4_time, 1, 0)									as ed_4_documented,
//flo_meas_starts,
Start_times,   
Clin_Just_time,
[Employee ID Start Res],
Start_date,
Unique_restraint_starts
Resident
Clin_just2
where exists (pat_enc_time, patenc_time)
order by   
%Pat_enc_csn,
Start_times;

//all four education rows must be complete in order to be compliant
Left join (Clin_just3)
Load
pat_enc_time,  
if(sum(ed_2_documented+ed_3_documented+ed_4_documented) = 3, 1, 0)			as [Education Rows Compliant]
resident Clin_just3
group by pat_enc_time;

Drop table Clin_just2;

//Link on pat enc and fsd_id to get start times 
Less_restrictive1:
NoConcatenate
Load distinct
%Pat_enc_csn &'-'& ([Recorded Time s and cl]) 			as patenc_time1,		//pat enc and recorded time key of restraints starts (due to limiting)
%Pat_enc_csn 
//&'-'& %FSD_ID_cl 							
as pat_enc_lr,
[Recorded Time s and cl] 								as Rec_time_start		//Recorded time of starts
//flo_meas_cls 											as Res_flo_meas
Resident
Clin_just   
where
flo_meas_cls <> '300106' // clin justification
and
flo_meas_cls <> '300104' // less restrictive
and
//flo_meas_cls <> '300108' //education rows
//and
flo_meas_cls <> '300109'
and
flo_meas_cls <> '300110'
and
flo_meas_cls <> '300111';


Less_restrictive:
NoConcatenate
Load 
pat_enc_lr,
patenc_time1 											as pat_enc_time,
pat_enc_lr &'-'& Rec_time_start 						as Start_Per_day,  
Rec_time_start											
//Res_flo_meas
Resident
Less_restrictive1 
where exists (pat_enc_time, patenc_time1); 

drop table Less_restrictive1;

Left join (Less_restrictive)   
Load
%Pat_enc_csn 
//&'-'& %FSD_ID_cl 
as pat_enc_lr,
[Recorded Time s and cl] as Less_Restrict_time1
Resident
Clin_just  
where
(flo_meas_cls = '300104');


Drop table Clin_just;

//create new key of pat_enc, fsd, and start time (can be multiple restraint starts at once), only load restrictive option times less than or equal to start
Less_restrictive2:
Noconcatenate 
Load distinct
pat_enc_lr,
Rec_time_start, 
Less_Restrict_time1 as Less_Restrict_time, 
pat_enc_lr &'-'& Rec_time_start as Start_Per_day
resident
Less_restrictive
where
timestamp (Less_Restrict_time1) <= timestamp (Rec_time_start)
or
Less_Restrict_time1 = null();



//give largest less restricted time (from table where restrictive time is less than or equal to start time)
Groupings:
Load distinct
Start_Per_day,
max(Less_Restrict_time) as Max_restrict_beforeorat_start
Resident
Less_restrictive2
group by 
Start_Per_day;

Drop table Less_restrictive2;

Left Join (Less_restrictive)
Load distinct
Start_Per_day,
timestamp(Max_restrict_beforeorat_start) 	as Max_restrict_beforeorat_start1
Resident 
Groupings;

drop table 
Groupings;

Less_restrictive_3:
NoConcatenate
Load Distinct
pat_enc_time,
//pat_enc_lr,
Rec_time_start,
//Start_Per_day,
Max_restrict_beforeorat_start1,
//Res_flo_meas,
if (Max_restrict_beforeorat_start1 <= (Rec_time_start)
and 
Max_restrict_beforeorat_start1 >= (interval(Rec_time_start - (120/1440), 'mm')), 1, 0) as Restriction_completed_in_time_frame,
timestamp(interval(Rec_time_start - (120/1440), 'mm')) as interval_test2
// [Employee ID Start Res1]
Resident
Less_restrictive
order by 
pat_enc_time;

Drop table Less_restrictive;

Employee_id:
LOAD	
    USER_ID													as [Employee ID Start Res],
    NAME													as [Employee Name Start Res],
    SYSTEM_LOGIN											as [Login ID Start Res1]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd)
where exists ([Employee ID Start Res], USER_ID);

// 

///$tab Calendar
Calendar_test:
LOAD
    "Date" as [Date],
    "Calendar Year",
    "Calendar Month",
    "Calendar Month Number",
    "Calendar Month Name"
FROM [$(vExtractDirectory)/FiscalCalendar.qvd]
(qvd)
where exists
([Date], "Date");

Order_Cal:
LOAD
    "Date" 						as Order_CAL,
    "Calendar Year"				as [Order Year],
    "Calendar Month"			as [Order Month]
//    "Calendar Month Number",
//     "Calendar Month Name"
FROM [$(vExtractDirectory)/FiscalCalendar.qvd]
(qvd)
where exists
([Date], "Date");

Restraint_Start:
LOAD
    "Date" 						as Start_date,
    "Calendar Year"				as [Restraint Start Year],
    "Calendar Month"			as [Restraint Start Month]
//    "Calendar Month Number",
//     "Calendar Month Name"
FROM [$(vExtractDirectory)/FiscalCalendar.qvd]
(qvd)
where exists
([Date], "Date");

 
///$tab Exit
Exit Script;
///$tab Clinical Justification and Less Restrictive 
Clin_just:
LOAD
    PAT_ENC_CSN_ID 																as %Pat_enc_csn,
    INPATIENT_DATA_ID  															as %inpatient_data_id_cl

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd)
where exists ([%Pat_enc_csn], PAT_ENC_CSN_ID);

//linking process from pat_enc_hsp to ip_flwsht_meas

inner join (Clin_just)
LOAD
    FSD_ID as %FSD_ID_cl,
    INPATIENT_DATA_ID as %inpatient_data_id_cl
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Clin_just)
LOAD
    FSD_ID 										as %FSD_ID_cl,
    timestamp(RECORDED_TIME) 					as [Recorded Time s and cl],
    MEAS_VALUE 									as Value_cls,
    FLO_MEAS_ID 								as flo_meas_cls,
    ENTRY_USER_ID								as [Employee ID Start Res]
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300120'//Mitt Secured R (NV)
OR
FLO_MEAS_ID = '300123'//'Soft Restraint L Wrist NV
or
FLO_MEAS_ID = '300122'//Soft Restraint R Wrist (NV)
OR
FLO_MEAS_ID = '300121'//'Mitt Secured L (NV)'
or 
FLO_MEAS_ID = '300124'//Soft Restraint R Ankle (NV)
or
FLO_MEAS_ID = '300125'//Soft Restraint L Ankle (NV)
or
FLO_MEAS_ID = '3040000175' //full rails 
or
FLO_MEAS_ID = '3040000176' //Enclosure Bed 
or
FLO_MEAS_ID = '3040000177' //seat belt
or
FLO_MEAS_ID = '3040000178' //Soft Belt (ICP)(NV) 
or
FLO_MEAS_ID = '300130' //Other
or
FLO_MEAS_ID = '300106' // Clinical justification
or
FLO_MEAS_ID = '300104')// Less Restrictive
and
MEAS_VALUE <> 'Continued'
and
MEAS_VALUE <> 'Discontinued'
and
MEAS_VALUE <> null();



Clin_just2:
NoConcatenate
Load
%Pat_enc_csn,
%Pat_enc_csn &'-'& ([Recorded Time s and cl]) 			as patenc_time,
date(floor( [Recorded Time s and cl])) 					as Start_date,
[Recorded Time s and cl]								as Start_times,
flo_meas_cls											as flo_meas_starts,
[Employee ID Start Res]
Resident
Clin_just 
where
flo_meas_cls <> '300106' and
flo_meas_cls <> '300104'
order by
%Pat_enc_csn,
[Recorded Time s and cl];

left join (Clin_just2) 
Load
%Pat_enc_csn &'-'& ([Recorded Time s and cl])						as patenc_time,
if (flo_meas_cls= '300106', date(floor( [Recorded Time s and cl]))) as Clin_Just_date,
if (flo_meas_cls= '300106', [Recorded Time s and cl]) 				as Clin_Just_time,
flo_meas_cls
Resident Clin_just
where flo_meas_cls= '300106'
order by
%Pat_enc_csn,
[Recorded Time s and cl];

 


Clin_just3:
NoConcatenate
Load
patenc_time as pat_enc_time,
if(Start_times = Clin_Just_time, 1, 0) as 'Clinical Justification Documented',
flo_meas_starts,
Start_times,   
Clin_Just_time,
[Employee ID Start Res],
Start_date
Resident
Clin_just2
where exists (pat_enc_time, patenc_time)
order by   
%Pat_enc_csn,
Start_times;


Drop table Clin_just2;

//different process for less restrictive - requires to be completed 2 hours to start time of restraint start
//Link on pat enc and fsd_id to get start times and time less restricted were documented
Less_restrictive1:
NoConcatenate
Load distinct
%Pat_enc_csn &'-'& ([Recorded Time s and cl]) 			as patenc_time1,
%Pat_enc_csn &'-'& %FSD_ID_cl 							as pat_enc_lr,
[Recorded Time s and cl] 								as Rec_time_start,
flo_meas_cls 											as Res_flo_meas
// [Employee ID Start Res]									as [Employee ID Start Res1]
Resident
Clin_just   
where
(flo_meas_cls <> '300106' // Clinical justification
and
flo_meas_cls <> '300104'
or 
);


Less_restrictive:
NoConcatenate
Load 
patenc_time1 											as pat_enc_time,
pat_enc_lr &'-'& Rec_time_start 						as Start_Per_day,  
pat_enc_lr,
Rec_time_start,
Res_flo_meas
Resident
Less_restrictive1 
where exists (pat_enc_time, patenc_time1); 

drop table Less_restrictive1;

Left join (Less_restrictive)   
Load
%Pat_enc_csn &'-'& %FSD_ID_cl as pat_enc_lr,
[Recorded Time s and cl] as Less_Restrict_time1
Resident
Clin_just  
where
(flo_meas_cls = '300104');

Drop table Clin_just;

//create new key of pat_enc, fsd, and start time (can be multiple restraint starts at once), only load restrictive option times less than or equal to start
Less_restrictive2:
Noconcatenate 
Load distinct
Rec_time_start, 
Less_Restrict_time1 					as Less_Restrict_time, 
pat_enc_lr,
pat_enc_lr &'-'& Rec_time_start 		as Start_Per_day
resident
Less_restrictive
where
timestamp (Less_Restrict_time1) <= timestamp (Rec_time_start)
or
Less_Restrict_time1 = null();



//give largest less restricted time (from table where restrictive time is less than or equal to start time)
Groupings:
Load distinct
Start_Per_day,								//unique key
max(Less_Restrict_time) 					as Max_restrict_beforeorat_start
Resident
Less_restrictive2
group by 
Start_Per_day;

Drop table Less_restrictive2;

Left Join (Less_restrictive)
Load distinct
Start_Per_day,  							//unique key
timestamp(Max_restrict_beforeorat_start) 	as Max_restrict_beforeorat_start1
Resident 
Groupings;

drop table 
Groupings;

Less_restrictive_3:
NoConcatenate
Load Distinct
pat_enc_time,								//links back to main restraints table in app
pat_enc_lr,
Rec_time_start,							
Start_Per_day,
Max_restrict_beforeorat_start1,
//Res_flo_meas,
if (Max_restrict_beforeorat_start1 <= (interval(Max_restrict_beforeorat_start1 - (2/1440), 'mm'))
and 
Max_restrict_beforeorat_start1 >= (interval(Max_restrict_beforeorat_start1 - (120/1440), 'mm')), 1, 0) as Restriction_completed_in_time_frame_m2,
if (Max_restrict_beforeorat_start1 <= (Max_restrict_beforeorat_start1)
and 
Max_restrict_beforeorat_start1 >= (interval(Max_restrict_beforeorat_start1 - (120/1440), 'mm')), 1, 0) as Restriction_completed_in_time_frame,
timestamp(interval(Max_restrict_beforeorat_start1 - (2/1440), 'mm')) as interval_test,
timestamp(interval(Max_restrict_beforeorat_start1 - (120/1440), 'mm')) as interval_test2
// [Employee ID Start Res1]
Resident
Less_restrictive
order by 
pat_enc_time;

Drop table Less_restrictive;

Employee_id:
LOAD	
    USER_ID													as [Employee ID Start Res],
//     USER_ID													AS [Employee ID Start Res1],
    NAME													as [Employee Name Start Res],
    SYSTEM_LOGIN											as [Login ID Start Res1]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);



///$tab Testing for Orders
Restraints_NV2:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Mitt Secured R (NV)'																			as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);
// Where
// PAT_ENC_CSN_ID = '37470425';


inner join (Restraints_NV2)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Restraints_NV2)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    if (MEAS_VALUE ='Yes', timestamp(RECORDED_TIME))			as [Time Returned to Unit],
    if (MEAS_VALUE = 'Yes-test/OR', timestamp(RECORDED_TIME))	as [Time Off Unit],
    if (MEAS_VALUE = 'Start', timestamp(RECORDED_TIME))			as [Start Restraint Episode],
    if (MEAS_VALUE ='Discontinued', timestamp(RECORDED_TIME))	as [End Restraint Episode Time],
    if (MEAS_VALUE = 'Yes', 'Returned to Unit',
    	if (MEAS_VALUE = 'Yes-test/OR', 'Off Unit', MEAS_VALUE))	as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State', 'Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order1,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300120'//Mitt Secured R (NV)
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
OR
FLO_MEAS_ID = '3040000181' //OFF UNIT
OR
FLO_MEAS_ID = '3040000182') // RETURNED TO UNIT
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Restraints_NV2)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);



Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Restraints_NV2
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order1 = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order1 = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Max([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order1 = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Restraints_NV2)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;

Restraints_NV:
Load
*,
if ((Value = 'Start' or Value = 'Returned to Unit'), 1, 
    	if(Value = 'Discontinued' or Value = 'Off Unit', 3, 2)) 	as Meas_Value_Order,
%Pat_enc_csn &'-'& [Recorded Time]        							as Group2_link,
recno()																as [rec num]
Resident
Restraints_NV2
where [Recorded Time] >= GroupStart
and
[Recorded Time] <= GroupEnd
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order1;


Drop Field Meas_Value_Order1;

Drop Table Restraints_NV2;

on_off:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time] as Group2_link,
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), [rec num],
	if(Meas_Value_Order = '1', [rec num], peek(group_id2)))   		as group_id2
Resident Restraints_NV
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Left join (Restraints_NV)
Load Distinct 
Group2_link,
group_id2
Resident
on_off;

Drop table on_off;

// //group_id1 is dropping fields inbetween start trurned to unit and //look to csn 37432542
Groupings:
Load
%Pat_enc_csn,
group_id2,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id2 = previous(group_id2),
    		if (GroupEnd >= [Recorded Time], 
    			if (GroupStart <= [Recorded Time], group_id2, null()))))) as group_id1
Resident
Restraints_NV
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;


left Join (Restraints_NV)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;




Restraints_NV1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id2,
[NV Restraint Type],
[Assessment Type],
Value,
[Login ID],
[Employee Name],
test_line,         //recno from or
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time

Resident
Restraints_NV
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017');


Drop Table Restraints_NV;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Restraints_NV1
WHERE Meas_Value_Order = '1'
// and [Time Returned to Unit]>[Start Restraint Episode]
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id2,
TimeStamp(Max([Recorded Time])) as GroupEnd
RESIDENT Restraints_NV1
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id2
;

Left Join (Restraints_NV1)
Load
%Pat_enc_csn,
group_id2,
GroupStart,
GroupEnd
Resident TimeTable;

Drop Table TimeTable;

Left Join (Restraints_NV1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Restraints_NV1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Restraints_NV1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Restraints_NV1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Restraints_NV1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Restraints_NV1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    sum([Compliant Count]) as Sum_Test
Resident 
[Restraints_NV1]
Where Meas_Value_Order = 2
group by
group_id1, 
check_order;


Left join ([Restraints_NV1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Restraints_NV1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Restraints_NV1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Restraints_NV1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Restraints_NV1
Where 
num(GroupEnd)>num([Recorded Time]);

LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

Restraints_Pat_enc:
Load
*
Resident 
Restraints_NV1;

Drop Table Restraints_NV1;



Dep:
LOAD 
    PAT_ENC_CSN 																AS [%Pat_enc_csn],
    Timestamp(IN_DTTM) 															AS [%DEP TIME IN],
    Timestamp(OUT_DTTM) 														AS [Department Time Out],
    ADT_DEPARTMENT_NAME 														AS [Department Name],
    ADT_LOC_NAME																AS [Location]
FROM [$(vExtractDirectory)/CLARITY_V_PAT_ADT_LOCATION_HX.qvd]
(qvd)
where exists ([%Pat_enc_csn], PAT_ENC_CSN);


Inner join (Dep)
LOAD
    PAT_ENC_CSN_ID 																as %Pat_enc_csn,
    INPATIENT_DATA_ID  															as %inpatient_data_id,
    'Mitt Secured R (NV)'														as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd)
where exists ([%Pat_enc_csn], PAT_ENC_CSN_ID);


inner join (Dep)
LOAD
    FSD_ID as %FSD_ID,
    INPATIENT_DATA_ID as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Dep)
LOAD
    FSD_ID as %FSD_ID,
//      "LINE" as %line,
    timestamp(RECORDED_TIME) as [Recorded Time],
    MEAS_VALUE as Value

FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300120'//Mitt Secured R (NV)
OR
FLO_MEAS_ID = '3040000182' //Returned to unit
OR
FLO_MEAS_ID = '3040000181' // OFF UNIT 
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118')//Elimination
and exists ([Recorded Time], RECORDED_TIME)
and
MEAS_VALUE <> 'Continued'
and
MEAS_VALUE <> null()
and
RECORDED_TIME <> null();

Dep1:
NoConcatenate
Load distinct
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
[%DEP TIME IN],
[Department Time Out],
if (num([Recorded Time])>=num([%DEP TIME IN]),
	IF (num([Recorded Time])<= num([Department Time Out]), [Department Name], null())) 	AS Department_1,
[Location]
Resident Dep
where
[Department Name] <> Null()
and 
num([Recorded Time])>=num([%DEP TIME IN])
and
num([Recorded Time])<= num([Department Time Out])
and 
exists ([%Pat_enc_csn])
and
exists ([Recorded Time]);

Drop Table Dep;



left join (Restraints_Pat_enc)
Load Distinct

pat_enc_time,
Department_1 as Department,
Location
resident Dep1
where
Department_1 <> Null();

Drop Table Dep1;




Order_proc:
Load
%Pat_enc_csn,
GroupStart   				as Start_Res,
GroupEnd 	 				as End_Res,
group_id2 					as group_proc //group id for start to end (including off and on units)
Resident
Restraints_Pat_enc
order by
%Pat_enc_csn,
group_id2;

left join (Order_proc)
LOAD distinct
    ORDER_PROC_ID,
    PAT_ID,
    PAT_ENC_CSN_ID as %Pat_enc_csn,
    INSTANTIATED_TIME as Instatiated_date,
    FUTURE_OR_STAND

FROM [lib://Extracts_Clarity_PROD/CLARITY_ORDER_PROC.qvd]
(qvd) 
where 
exists (%Pat_enc_csn, PAT_ENC_CSN_ID)
and
INSTANTIATED_TIME <> null() 
and
PROC_CODE = 'RES4';
// and PAT_ENC_CSN_ID =
// '37470425';
  
Order_Proc1:
NoConcatenate
Load Distinct 
*
Resident
Order_proc 
where
(Instatiated_date)<= (End_Res) //only bring in orders less than restraint end time for episode (same order proc could be placed for other restraint types episodes)
and
date(floor(Instatiated_date))>= (date(floor(Start_Res))-1) //minus 1 day to ensure there is an order active when the clinician documents start of restraint
order by
%Pat_enc_csn,
group_proc;


Drop table Order_proc;  

// create previous order column for comparison, if group proc (which signifies start to end episode) = previous group proc, give me the previous order instantiated time, else give me the restraint start time (to ensure restraints were started with an active order)
Order2:
NoConcatenate
Load Distinct 
%Pat_enc_csn, 
group_proc,
Start_Res,
End_Res,
Instatiated_date as inst_date,
if (group_proc = Previous(group_proc), previous(Instatiated_date), Start_Res) as Previous_order,
recno()              as Rec_join
Resident 
Order_Proc1
order By
%Pat_enc_csn,
group_proc,
// Meas_Order,
Instatiated_date;  

drop table Order_Proc1; 

//if start restraint time = previous order, signifying the first order before the start of restraint episode, subtract that Start Time from the first instantiated order, else give me time between orders during the episode
Left join
(Order2)
Load
Rec_join,
if (Start_Res = Previous_order, 
	(interval(Previous_order - inst_date,'hh:mm:ss')),
    	(interval(inst_date - Previous_order, 'hh:mm:ss'))) as Time_between_orders
//interval(inst_date - Previous_order, 'hh:mm:ss')	as Time_between_orders
Resident
Order2;

Left join
(Order2)
Load
Rec_join,
if(Time_between_orders <= '24:00:00', 1, 0) as [Compliant Order?]
Resident
Order2; 

Left join (Order2)
Load
group_proc,
(Interval(End_Res - Start_Res, 'dd')) as Start_to_end_req_orders
Resident
Order2; 


Order_sum:
Load Distinct
group_proc,
min(Rec_join) as min_join,
sum([Compliant Order?]) as Compliance_Ord,
Start_to_end_req_orders as Orders_Req  //Plus 1 for initial starting order??// 
// Sum([Compliant Order?]) as Order_Comp_total,
// Sum ([Start_to_end_req_orders]) as Order_req
Resident
Order2
group by group_proc,
Start_to_end_req_orders;           

//join back on only one line per Group_proc compliance totals
left join (Order2)
Load Distinct
min_join as Rec_join,
Compliance_Ord as [Total Compliant Orders Placed],
Orders_Req as [Episode Order Requirements]
Resident   
Order_sum;    

Drop table Order_sum; 

///$tab Clinical Justification
// Clin_just:
// LOAD
//     PAT_ENC_CSN_ID 																as %Pat_enc_csn,
//     INPATIENT_DATA_ID  															as %inpatient_data_id_cl

// FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
// (qvd)
// where exists ([%Pat_enc_csn], PAT_ENC_CSN_ID);


// inner join (Clin_just)
// LOAD
//     FSD_ID as %FSD_ID_cl,
//     INPATIENT_DATA_ID as %inpatient_data_id_cl
// FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
// (qvd);


// inner join (Clin_just)
// LOAD
//     FSD_ID 								as %FSD_ID_cl,
//     timestamp(RECORDED_TIME) 			as [Recorded Time s and cl],
//     MEAS_VALUE 							as Value_cls,
//     FLO_MEAS_ID 						as flo_meas_cls,
//     ENTRY_USER_ID						as [Employee ID Start Res]

// FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
// (qvd)
// Where 
// (FLO_MEAS_ID = '300120'//Mitt Secured R (NV)
// OR
// FLO_MEAS_ID = '300123'//'Soft Restraint L Wrist NV
// or
// FLO_MEAS_ID = '300122'//Soft Restraint R Wrist (NV)
// OR
// FLO_MEAS_ID = '300121'//'Mitt Secured L (NV)'
// or 
// FLO_MEAS_ID = '300124'//Soft Restraint R Ankle (NV)
// or
// FLO_MEAS_ID = '300125'//Soft Restraint L Ankle (NV)
// or
// FLO_MEAS_ID = '3040000175' //full rails 
// or
// FLO_MEAS_ID = '3040000176' //Enclosure Bed 
// or
// FLO_MEAS_ID = '3040000177' //seat belt
// or
// FLO_MEAS_ID = '3040000178' //Soft Belt (ICP)(NV) 
// or
// FLO_MEAS_ID = '300130' //Other
// or
// FLO_MEAS_ID = '300106')// Clinical justification
// and
// MEAS_VALUE <> 'Continued'
// and
// MEAS_VALUE <> 'Discontinued'
// and
// MEAS_VALUE <> null();


// Clin_just2:
// NoConcatenate
// Load
// %Pat_enc_csn,
// %Pat_enc_csn &'-'& ([Recorded Time s and cl]) 			as patenc_time,
// date(floor( [Recorded Time s and cl])) 					as Start_date,
// [Recorded Time s and cl]								as Start_times,
// flo_meas_cls											as flo_meas_starts,
// [Employee ID Start Res]
// Resident
// Clin_just 
// where
// flo_meas_cls <> '300106'
// order by
// %Pat_enc_csn,
// [Recorded Time s and cl];

// left join (Clin_just2) 
// Load
// %Pat_enc_csn &'-'& ([Recorded Time s and cl])						as patenc_time,
// if (flo_meas_cls= '300106', date(floor( [Recorded Time s and cl]))) as Clin_Just_date,
// if (flo_meas_cls= '300106', [Recorded Time s and cl]) 				as Clin_Just_time,
// flo_meas_cls
// Resident Clin_just
// where flo_meas_cls= '300106'
// order by
// %Pat_enc_csn,
// [Recorded Time s and cl];

// Drop table Clin_just; 


// Clin_just3:
// NoConcatenate
// Load
// //%Pat_enc_csn,
// patenc_time as pat_enc_time,
// if(Start_times = Clin_Just_time, 1, 0) as 'Clinical Justification Documented',
// flo_meas_starts,
// Start_times,   
// Clin_Just_time,
// [Employee ID Start Res]
// Resident
// Clin_just2
// where exists (pat_enc_time, patenc_time)
// order by   
// %Pat_enc_csn,
// Start_times;

// Drop table Clin_just2;


// Left Join (Clin_just3)
// LOAD
//     USER_ID													as [Employee ID Start Res],
//     NAME													as [Employee Name Start Res],
//     SYSTEM_LOGIN											as [Login ID Start Res]
// FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
// (qvd);

///$tab Less Restrictive Alternative
//300104

Clin_just:
LOAD
    PAT_ENC_CSN_ID 																as %Pat_enc_csn,
    INPATIENT_DATA_ID  															as %inpatient_data_id_cl

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd)
where exists ([%Pat_enc_csn], PAT_ENC_CSN_ID);


inner join (Clin_just)
LOAD
    FSD_ID as %FSD_ID_LR,
    INPATIENT_DATA_ID as %inpatient_data_id_cl
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Clin_just)
LOAD
    FSD_ID 								as %FSD_ID_LR,
    timestamp(RECORDED_TIME) 			as [Recorded Time s and cl],
    MEAS_VALUE 							as Value_cls,
    FLO_MEAS_ID 						as flo_meas_cls,
    ENTRY_USER_ID						as [Employee ID Start Res]

FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300120'//Mitt Secured R (NV)
OR
FLO_MEAS_ID = '300123'//'Soft Restraint L Wrist NV
or
FLO_MEAS_ID = '300122'//Soft Restraint R Wrist (NV)
OR
FLO_MEAS_ID = '300121'//'Mitt Secured L (NV)'
or 
FLO_MEAS_ID = '300124'//Soft Restraint R Ankle (NV)
or
FLO_MEAS_ID = '300125'//Soft Restraint L Ankle (NV)
or
FLO_MEAS_ID = '3040000175' //full rails 
or
FLO_MEAS_ID = '3040000176' //Enclosure Bed 
or
FLO_MEAS_ID = '3040000177' //seat belt
or
FLO_MEAS_ID = '3040000178' //Soft Belt (ICP)(NV) 
or
FLO_MEAS_ID = '300130' //Other
or
FLO_MEAS_ID = '300104')// Clinical justification
and
MEAS_VALUE <> 'Continued'
and
MEAS_VALUE <> 'Discontinued'
and
MEAS_VALUE <> null();


Clin_just2:
NoConcatenate
Load
%Pat_enc_csn,
%FSD_ID_LR,
([Recorded Time s and cl]) 								as patenc_time,
date(floor( [Recorded Time s and cl])) 					as Start_date,
[Recorded Time s and cl]								as Start_times,
flo_meas_cls											as flo_meas_starts,
[Employee ID Start Res]
Resident
Clin_just 
where
flo_meas_cls <> '300104'
order by
%Pat_enc_csn,
[Recorded Time s and cl];

left join (Clin_just2) 
Load
%FSD_ID_LR,
if (flo_meas_cls= '300104', date(floor( [Recorded Time s and cl]))) as Clin_Just_date,
if (flo_meas_cls= '300104', [Recorded Time s and cl]) 				as Clin_Just_time,
flo_meas_cls
Resident Clin_just
where flo_meas_cls= '300104'
order by
%Pat_enc_csn,
[Recorded Time s and cl];

Drop table Clin_just; 


Clin_just3:
NoConcatenate
Load
//%Pat_enc_csn,
patenc_time as pat_enc_time,
if(Start_times = Clin_Just_time, 1, 0) as 'Clinical Justification Documented',
flo_meas_starts,
Start_times,   
Clin_Just_time,
[Employee ID Start Res]
Resident
Clin_just2
where exists (pat_enc_time, patenc_time)
order by   
%Pat_enc_csn,
Start_times;

Drop table Clin_just2;


Left Join (Clin_just3)
LOAD
    USER_ID													as [Employee ID Start Res],
    NAME													as [Employee Name Start Res],
    SYSTEM_LOGIN											as [Login ID Start Res]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);

///$tab Separate 
exit script;
///$tab Mitt Secured R (NV) OLD VERSION
Restraints_NV:
LOAD
    PAT_ENC_CSN_ID 																					as %Pat_enc_csn,
    If ("Behavioral Health Encounter Flag"=1, 'Redacted', [PAT_ID])   								as [Patient ID],
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_NAME_MAP', PAT_ID)) 	as [Patient Name], 
	If ("Behavioral Health Encounter Flag"=1, 'Redacted', APPLYMAP ('PATIENT_MRN_MAP', PAT_ID)) 	as [MRN],
    INPATIENT_DATA_ID  																				as %inpatient_data_id,
    'Mitt Secured R (NV)'																			as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd);


inner join (Restraints_NV)
LOAD
    FSD_ID 														as %FSD_ID,
    INPATIENT_DATA_ID 											as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Restraints_NV)
LOAD
    FSD_ID 														as %FSD_ID,
     "LINE" 													as %line,
    FLO_MEAS_ID 												as FLO_MEAS_ID,
    OCCURANCE,
    timestamp(RECORDED_TIME) 									as [Recorded Time],
	ENTRY_USER_ID												as [Employee ID],
    MEAS_VALUE as Value,
    Pick(Match(FLO_MEAS_ID, '300113', '300114', '3040000179', '3040000180', '300115', '300116', '300117', '300118')+1, 'Begin, Continued, or Discontined Time', 'Emotional State', 'Circulation', 'Respirations', 'Comfort Level', 'Range of Motion', 'Fluids', 'Food/Meal', 'Elimination')as [Assessment Type],
    if (MEAS_VALUE = 'Start', 1, 
    	if(MEAS_VALUE= 'Discontinued', 3, 2)) 					as Meas_Value_Order,
    if (MEAS_VALUE = 'Start', 1, 0)								as [NV Episode Count],
    recno()    													as test_line
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
(FLO_MEAS_ID = '300120'//Mitt Secured R (NV)
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118')//Elimination
and 
(MEAS_VALUE <> 'Continued'
and 
len(trim(MEAS_VALUE))>0)
;

// Emotional State - 300113 
// Circulation - 300114
// Respirations - 3040000179
// Comfort Level - 3040000180
// Range of Motion - 300115
// Fluids - 300116
// Food/Meal - 300117
// Elimination - 300118


Left Join (Restraints_NV)
LOAD
    USER_ID													as [Employee ID],
    NAME													as [Employee Name],
    SYSTEM_LOGIN											as [Login ID]
FROM [$(vExtractDirectory)/CLARITY_CLARITY_EMP.qvd]
(qvd);


Temp_Table:
NoConcatenate
Load
*,
recno()     													as Rec_id
Resident
Restraints_NV
order by
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;


//if csn does not equal previous cn, give me the new rec id, if meas_value_order = '1' (indicating a meas_value of start), give me that new rec id, otherwise give me the same rec_id as before (in order to groups from start, assessments, to discontinue)
Temp:
NoConcatenate Load
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order,
if(%Pat_enc_csn <>previous(%Pat_enc_csn), Rec_id,
	if(Meas_Value_Order = '1', Rec_id, peek(group_id)))   		as group_id
Resident Temp_Table
ORDER BY 
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order;

Drop Table Temp_Table;

TimeTable:
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(MIN([Recorded Time])) 								as GroupStart
RESIDENT Temp
WHERE Meas_Value_Order = '1'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (TimeTable)
LOAD DISTINCT
%Pat_enc_csn,
group_id,
TimeStamp(Max([Recorded Time])) as GroupEnd
RESIDENT Temp
WHERE Meas_Value_Order = '3'
GROUP BY %Pat_enc_csn, group_id
;

Left Join (Temp)
LOAD * 
Resident TimeTable;

Drop Table TimeTable;


Left Join (Restraints_NV)
LOAD DISTINCT
%Pat_enc_csn,
[Recorded Time],
Meas_Value_Order,
group_id,
GroupStart,
GroupEnd
Resident Temp;

Drop Table Temp;


Groupings:
Load
%Pat_enc_csn,
group_id,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
if(Meas_Value_Order = '1', 'Start Restraint',
	if(Meas_Value_Order = '3', 'End Restraint',
        if(group_id = previous(group_id),
    		if (GroupEnd >= [Recorded Time], 
    			if (GroupStart <= [Recorded Time], group_id, null()))))) as group_id1
Resident
Restraints_NV
Order by
%Pat_enc_csn,
group_id,
[Recorded Time], 
Meas_Value_Order;


left Join (Restraints_NV)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time]
Resident
Groupings
where
len(trim(group_id1))>0;

Drop Table Groupings;




Restraints_NV1:
Load Distinct
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
date(floor([Recorded Time])) 									as [Date],
group_id,
[NV Restraint Type],
[Assessment Type],
Value,
GroupStart,
GroupEnd,
[Login ID],
[Employee Name],
test_line,         //recno from or
[Patient Name], 
[Patient ID],
[MRN], 
[NV Episode Count],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time

Resident
Restraints_NV
where
len(trim(group_id1))>0
and
(date(floor([Recorded Time]))>='04/01/2017');


Drop Table Restraints_NV;



Left Join (Restraints_NV1)
Load
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
Meas_Value_Order,
[Recorded Time],
If(group_id1 = previous(group_id1), 
	if ([FLO_MEAS_ID]= previous([FLO_MEAS_ID]),
    	peek([Recorded Time]), GroupStart),GroupStart)  					as Testing_interval
Resident
Restraints_NV1
Order by
%Pat_enc_csn,
group_id1,
FLO_MEAS_ID,
[Recorded Time]; 




Left Join (Restraints_NV1)
Load
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
Meas_Value_Order,
[Recorded Time],
interval([Recorded Time]-Testing_interval, 'ss') 						as [Time Between Assessments Seconds],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 1, 0) 	as [Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 1, 0) 	as [Non-Compliant Count],
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')<='02:00:01', 'Compliant Row',
if(interval([Recorded Time]-Testing_interval, 'hh:mm:ss')>'02:00:01', 'Non-Compliant Row', 'N/A')) as 'Compliant Row Assessment?'


Resident
Restraints_NV1
where
Meas_Value_Order = '2'
Order by
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Left join (Restraints_NV1)
Load
	test_line,
	if([FLO_MEAS_ID]=previous([FLO_MEAS_ID]) and [group_id1]=previous([group_id1]), peek([check_order])+1,1) as [check_order]
RESIDENT Restraints_NV1
where
Meas_Value_Order = 2
ORDER BY 
%Pat_enc_csn,
group_id1,
[FLO_MEAS_ID],
[Recorded Time]; 

Temp_31:
Load
check_order,
group_id1,
min(test_line)   																	as min_test_line,
if (sum([Compliant Count])>=8, 1, 0) as [All Assessment Rows Complete Count1],
if (sum([Compliant Count])>=8, 'Compliant Group Assessment',
	if (sum([Compliant Count])<8, 'Non Compliant Group Assessment')) as [Compliant Group Assessment?],
    sum([Compliant Count]) as Sum_Test
Resident 
[Restraints_NV1]
Where Meas_Value_Order = '2'
group by
group_id1, 
check_order;


Left join ([Restraints_NV1])
Load
min_test_line as test_line,
[All Assessment Rows Complete Count1] 												as [All Assessment Rows Complete Count],
group_id1 &'-'& check_order 														as groupid_check_count,
group_id1,
[Compliant Group Assessment?]
Resident
Temp_31;

Drop table Temp_31;


Denominator:
Load
%Pat_enc_csn,
if(Len(trim(GroupStart)>0), [FLO_MEAS_ID]) 											as Restraint_flomeas_start,
if(Len(trim(GroupEnd)>0), [FLO_MEAS_ID])				 							as Restraint_flomeas_end,
GroupStart as [GroupStart Denom],
GroupEnd as [GroupEnd Denom],
[Recorded Time],
group_id1,
Meas_Value_Order,
test_line
//recorded_time
Resident 
Restraints_NV1
where 
Meas_Value_Order = '1'
or
Meas_Value_Order = '3'
order by
%Pat_enc_csn,
[FLO_MEAS_ID],
[Recorded Time];


Denom_Calc:
NoConcatenate
Load
*,
if (Restraint_flomeas_start = Restraint_flomeas_end, interval([GroupEnd Denom]-[GroupStart Denom], 'mm')) as [Start to End]
Resident
Denominator
Order by
%Pat_enc_csn,
[Recorded Time];

Drop Table
Denominator;



Left Join (Restraints_NV1)
Load Distinct
group_id1,
test_line,
floor([Start to End]/(1/12)) 													as 'Start to End Documentation Requirements'// to divide by 2 hours, must divide bt 1/12 because 2 hours is 1/12 or a day
Resident
Denom_Calc
where
Meas_Value_Order = '1';


Drop Table
Denom_Calc;

Left Join (Restraints_NV1)
Load Distinct
groupid_check_count,
[All Assessment Rows Complete Count] 											as [Compliant Points Start to Discontinued]
Resident
Restraints_NV1
Where 
num(GroupEnd)>num([Recorded Time]);

LOAD
// preceding load to calculate each measure; using dual for sorting ability
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DUAL(
IF(Num#([Time Between Assessments Seconds]) >= $(vYears),
FLOOR(Num#([Time Between Assessments Seconds])/ROUND($(vYears))) & 'y ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vDays)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vYears))/$(vDays)) & 'd ',
) &
IF(Num#([Time Between Assessments Seconds]) >= ($(vHours)),
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vDays))/$(vHours)) & 'h ',
) &
FLOOR(MOD(ROUND(Num#([Time Between Assessments Seconds])), $(vHours))/$(vSixty)) & 'm ' 
//&
//IF(FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) > 0,
//FLOOR(MOD(MOD(ROUND(Num#([Extubation Duration for Prior to Reintubation in Seconds])), $(vHours)), $(vSixty))) & 's')
,
Num#([Time Between Assessments Seconds])) as [Time Between Assessments]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

LOAD
               *,
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//preceding load to roll up dimensions by different time slices
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//creating different time fields to find the differences 
Round(Num#([Time Between Assessments Seconds]) / $(vSixty)) as [Time Between Assessments in Minutes],
Round(Num#([Time Between Assessments Seconds]) / $(vHours)) as [Time Between Assessments in Hours],
Round(Num#([Time Between Assessments Seconds]) / $(vDays)) as [Time Between Assessments in Days],
Round(Num#([Time Between Assessments Seconds]) / $(vYears)) as [Time Between Assessments in Years]
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
;

Restraints_Pat_enc:
Load
*
Resident 
Restraints_NV1;

Drop Table Restraints_NV1;


Dep:
LOAD 
    PAT_ENC_CSN 																AS [%Pat_enc_csn],
    IN_DTTM 																	AS [%DEP TIME IN],
    OUT_DTTM 																	AS [%DEP TIME OUT],
    ADT_DEPARTMENT_NAME 														AS [Department Name],
    ADT_LOC_NAME																AS [Location]
FROM [$(vExtractDirectory)/CLARITY_V_PAT_ADT_LOCATION_HX.qvd]
(qvd)
where exists ([%Pat_enc_csn], PAT_ENC_CSN);


Inner join (Dep)
LOAD
    PAT_ENC_CSN_ID 																as %Pat_enc_csn,
    INPATIENT_DATA_ID  															as %inpatient_data_id,
    'Mitt Secured R (NV)'														as [NV Restraint Type]

FROM [$(vExtractDirectory)/CLARITY_PAT_ENC_HSP.qvd]
(qvd)
where exists ([%Pat_enc_csn], PAT_ENC_CSN_ID);


inner join (Dep)
LOAD
    FSD_ID as %FSD_ID,
    INPATIENT_DATA_ID as %inpatient_data_id
FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_REC.qvd]
(qvd);


inner join (Dep)
LOAD
    FSD_ID as %FSD_ID,
     "LINE" as %line,
    timestamp(RECORDED_TIME) as [Recorded Time],
    MEAS_VALUE as Value

FROM [$(vExtractDirectory)/CLARITY_IP_FLWSHT_MEAS.qvd]
(qvd)
Where 
FLO_MEAS_ID = '300120'//Mitt Secured R (NV)
OR
FLO_MEAS_ID = '300113' //emotional state
OR
FLO_MEAS_ID = '300114' //circulation
or
FLO_MEAS_ID = '3040000179'//Respirations
or
FLO_MEAS_ID = '3040000180'// Comfort Level
or
FLO_MEAS_ID = '300115'//Range of Motion
or
FLO_MEAS_ID = '300116'//Fluids
or
FLO_MEAS_ID = '300117'//Food/Meal
or
FLO_MEAS_ID = '300118'//Elimination
;

Dep1:
NoConcatenate
Load Distinct
%Pat_enc_csn,
[Recorded Time],
%Pat_enc_csn &'-'& [Recorded Time]  as pat_enc_time,
[%DEP TIME IN],
[%DEP TIME OUT],
if (num([Recorded Time])>num([%DEP TIME IN]),
	IF (num([Recorded Time])< num([%DEP TIME OUT]), [Department Name], null())) 	AS Department_1,
[Location]
Resident Dep
where
[Department Name] <> Null()
and 
num([Recorded Time])>num([%DEP TIME IN])
and
num([Recorded Time])< num([%DEP TIME OUT])
and 
exists ([%Pat_enc_csn]);

Drop Table Dep;


Dep2V:
NoConcatenate
Load Distinct 
pat_enc_time,
Department_1 as Department,
Location
resident Dep1
where
Department_1 <> Null()
and
exists 
(pat_enc_time);

Drop Table Dep1;





///$tab Section
Order_Proc1:
LOAD distinct
    ORDER_PROC_ID,
    PAT_ID,
    PAT_ENC_DATE_REAL,
    PAT_ENC_CSN_ID as %Pat_enc_csn,
    INSTANTIATED_TIME as Instatiated_date,
    FUTURE_OR_STAND

FROM [lib://Extracts_Clarity_PROD/CLARITY_ORDER_PROC.qvd]
(qvd) 
where 
// exists (%Pat_enc_csn, PAT_ENC_CSN_ID)
INSTANTIATED_TIME <> null() 
and
PROC_CODE = 'RES4'
and PAT_ENC_CSN_ID =
'37470425';
  


Order2:
NoConcatenate
Load 
//Distinct 
%Pat_enc_csn, 
Instatiated_date as inst_date,
if (%Pat_enc_csn = Previous(%Pat_enc_csn), previous(Instatiated_date), Instatiated_date) as Previous_order
Resident 
Order_Proc1
order By
%Pat_enc_csn,
Instatiated_date;  
